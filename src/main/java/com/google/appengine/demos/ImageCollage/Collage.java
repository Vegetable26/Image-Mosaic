package com.google.appengine.demos.ImageCollage;

/*
 Update: 12/23
 Added the artist attribution table
 Added a color-in image downloader for large blocks

 Collage: Called by CollageMaster() to generate a collage from a given base image.The collage is generated by recursively
 generating a quad-tree until each block's RGB values are below a given variance threshold. Finally, it generates a List of AttributionCells which
 details the artist and original URL of each color-in image.
*/

import com.google.appengine.api.images.Composite;
import com.google.appengine.api.images.Image;
import com.google.appengine.api.images.ImagesService;
import com.google.appengine.api.images.ImagesServiceFactory;

import java.io.IOException;
import java.util.List;
import java.util.ArrayList;

public class Collage {

    private  ProcessedImage processedImage; // Base image, which the collage will be built from
    private ImagesService imgService; //
    private  int width; // Width of the base image
    private  int height; // Height of the base image
    private  int maxDepth; // Maximum quad-tree depth
    private  int varianceThreshhold; // Stop condition for the quad-tree recursion
    private  Crawler crawler; // Finds images from the database
    private int factor = 1; // Scaling factor of the image, default at 1
    private List<AttributionCell> attributionTable = new ArrayList<AttributionCell>();
    private int initialX; // Used to define the top left x,y coordinates of the image within the Master-Collage
    private int initialY;
    private double alpha = .4; // The opacity of the original image in the collage

    /*

    Constructs a Collage object, with the default alpha overlay value

     */

    public Collage(Image inputImg, int maxDepth, int varianceThreshhold, int factor, Crawler crawler, int initialX, int initialY){

        setParameters(inputImg, maxDepth, varianceThreshhold, factor, crawler, initialX, initialY);

    }

    /*

    Constructs a Collage object, with the given alpha overlay value

     */

    public Collage(Image inputImg, int maxDepth, int varianceThreshhold, int factor, Crawler crawler, int initialX, int initialY, double alpha){

        setParameters(inputImg, maxDepth, varianceThreshhold, factor, crawler, initialX, initialY);
        this.alpha = alpha;

    }

    /*

    Sets the member variables of the Collage object, called from the Constructors

     */

    private void setParameters(Image inputImg, int maxDepth, int varianceThreshhold, int factor, Crawler crawler, int initialX, int initialY){

        this.factor = factor;
        this.crawler = crawler;
        processedImage = new ProcessedImage(inputImg, null, null, null);
        this.maxDepth = maxDepth;
        height = inputImg.getHeight();
        width = inputImg.getWidth();
        this.initialX = initialX;
        this.initialY = initialY;
        this.varianceThreshhold =  varianceThreshhold;
        imgService = ImagesServiceFactory.getImagesService();

    }


    /*

    Returns an Image of the finished, alpha-overlaid collage

     */

    public Image getCollage(){

        return alphaOverlay(colorBlock(0, 0, height, width, 0, processedImage));

        // Calls the recursive colorBlock on the entire base-image

    }

    /*

    Creates/Returns a collage within a given block of the base-image

    Inputs: firstX: X coordinate of the upper-left corner
    firstY: Y coordinate of the upper-left corner
    partitionHeight: The height of the block
    partitionWidth: The width of the block
    depth: The current recursion depth of the colorBlock() call
    colorMe: Subsection of the base-image to be collaged

     */

    private Image colorBlock(int firstX, int firstY, int partitionHeight, int partitionWidth, int depth, ProcessedImage colorMe){

        if(firstX<width && firstY<height) { // Prevents colorBlock() from creating a collage outside of the given base-image
            if (depth < maxDepth) { // Prevents colorBlock() from recursing past the maxDepth
                int halfWidth = partitionWidth / 2; // halfWidth is the width  of the block within the next depth's colorBlock()
                int halfHeight = partitionHeight / 2; // halfHeight is the height of the block within the next depth's colorBlock()
                double variance = colorMe.getVariance();

                // Finds the variance of the RGB values within the block

                if (variance > varianceThreshhold){ // Stops the quad-tree from recursing if the variance is below the threshhold
                    depth++; // Increments the depth for the recursed colorBlock() calls
                    ArrayList<Composite> composites = new ArrayList<Composite>(); // Stores the returned collages from the 4 quadrants of the block       
                    Image upperLeft = colorBlock(firstX, firstY, halfHeight, halfWidth, depth, colorMe.getBlock(0, 0, halfHeight, halfWidth)); // Upper Left
                    Image upperRight = colorBlock(firstX + halfWidth, firstY, halfHeight, partitionWidth - halfWidth, depth, colorMe.getBlock(halfWidth, 0, halfHeight, partitionWidth - halfWidth)); // Upper Right
                    Image lowerLeft = colorBlock(firstX, firstY + halfHeight, partitionHeight-halfHeight, halfWidth, depth, colorMe.getBlock(0, halfHeight, partitionHeight-halfHeight, halfWidth)); // Lower Left
                    Image lowerRight = colorBlock(firstX + halfWidth, firstY + halfHeight, partitionHeight-halfHeight, partitionWidth - halfWidth, depth, colorMe.getBlock(halfWidth, halfHeight, partitionHeight-halfHeight, partitionWidth - halfWidth)); // Lower Right
                    
                    // Recursively calls colorBlock() on the 4 quadrants of the block
                    
                    composites.add(ImagesServiceFactory.makeComposite(upperLeft,0,0,1f, Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(upperRight, halfWidth*factor, 0, 1f, Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(lowerLeft,0, halfHeight*factor,1f,Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(lowerRight,(halfWidth)*factor, (halfHeight)*factor,1f,Composite.Anchor.TOP_LEFT));
                    
                    // Transforms all the returned quadrant Images to Composites
                    
                    return imgService.composite(composites,partitionWidth*factor,partitionHeight*factor,0); // Returns the composited image, scaled by the factor
                }
                else{ // The variance was below the threshold
                    return findImage(colorMe, firstX,firstY, partitionHeight, partitionWidth,depth); // Fills the block with a single image
                }
            }
            else { // This colorBlock() call was already at max depth
                return findImage(colorMe, firstX,firstY,partitionHeight, partitionWidth,depth); // Fills the block with a single image

            }
        }
        return null; // Returns a null image if this colorBlock() modifies pixels outside of the base-image

    }
    
    /*
    
    Returns an image from the database that best matches the RGB histogram of a given block

    Inputs: firstX: X coordinate of the upper-left corner of the block
    firstY: Y coordinate of the upper-left corner of the block
    partitionHeight: height of the block
    partitionWidth: width of the block
    depth: Depth at which findImage() was called

     */
    
    private Image findImage( ProcessedImage block, int firstX, int firstY, int partitionHeight, int partitionWidth, int depth){

        ProcessedImage processed =  crawler.ditherQuery(block.getRGBHistogram());

        // Creates a ProcessedImage from the closest matching image within the database

        if(depth<1){ // If the depth is too low download a higher quality version of the found image to put in the collage
            try {
                processed = new ProcessedImage(processed.getSmallUrl(), processed.getUsername(), processed.getId());
            }catch(IOException e){ // If the image cannot be read from the Url, use the thumbnail

            }
        }
        attributionTable.add(new AttributionCell(firstX+initialX,firstY+initialY,firstX+initialX+partitionWidth,firstY+initialY+partitionHeight,processed.getUsername(),processed.getUrl(),processed.getId()));

        // Stores the author, URL, and position of the used Flickr image

        return processed.getScaled(partitionWidth*factor,partitionHeight*factor); // Returns a scaled copy of the image

    }

    /*

    Returns the attributionTable of the Collage

     */


    public List<AttributionCell> getAttributionTable(){

        return attributionTable;

    }

    /*

    Overlays a alpha% opacity copy of the original image on the collage to create a more accurate image

    */

    private Image alphaOverlay(Image collage){

        ArrayList<Composite>composites = new ArrayList<Composite>(); // Stores the composite images
        composites.add(ImagesServiceFactory.makeComposite(processedImage.getImage(),0,0,(float)alpha, Composite.Anchor.TOP_LEFT));

        // Turns the collage into a composite with full opacity

        composites.add(ImagesServiceFactory.makeComposite(collage,0,0,.85f,Composite.Anchor.TOP_LEFT));

        // Turns the original image into a composite with alpha% opacity

        return imgService.composite(composites,width*factor,height*factor,0); // Returns the overlaid collage and alpha% opacity base-image

    }

    /*

    AttributionCell: Stores the author, URL, and position information of the Flickr images within the collage

    */

    public class AttributionCell{

        double x1; // X coordinates of the upper-left corner
        double x2; // X coordinates of the bottom-right corner
        double y1; // Y coordinates of the upper-left corner
        double y2; // Y coordinates of the bottom-right corner
        String author; // Flickr username of the artist
        String trueUrl; // Url of the Flickr image
        String id; // Flickr id of the artist

        /*

        Constructs an AttributionCell

        Inputs: url: Thumbnail url of the image
        */

        public AttributionCell(double x1, double y1, double x2, double y2, String author, String url, String id){

            this.x1 = x1;
            this.x2 = x2;
            this.y1 = y1;
            this.y2 = y2;
            this.author = author;
            this.id = id;
            findUrl(url); // Constructs the trueUrl from the thumbnail url

        }

        /*

        Constructs the Flickr page url from the thumbnail url and userId

        Inputs: url: thumbnail url

        */

        private void findUrl(String url){

            try {
                String codeNumber = url.split("[^a-zA-Z0-9 ]")[8]; // Splits the thumbnail url to find the image number
                trueUrl = codeNumber.split("_")[0];
                trueUrl = "https://www.flickr.com/photos/" +  id + "/" + trueUrl; // Creates the url of the actual Flickr page
            }catch(Exception e){

                trueUrl = url; // If there was an error, simply return the thumbnail url

            }

        }

    }

}
